/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

public partial class BlockWorkerClientService {
  public interface Iface : AlluxioService.Iface {
    /// <summary>
    /// Accesses a block given the block id.
    /// </summary>
    /// <param name="blockId">the id of the block being accessed</param>
    void accessBlock(long blockId);
    #if SILVERLIGHT
    IAsyncResult Begin_accessBlock(AsyncCallback callback, object state, long blockId);
    void End_accessBlock(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Asynchronously checkpoints a file: returns whether the checkpoint operation succeeded.
    /// </summary>
    /// <param name="fileId">the id of the file being accessed</param>
    bool asyncCheckpoint(long fileId);
    #if SILVERLIGHT
    IAsyncResult Begin_asyncCheckpoint(AsyncCallback callback, object state, long fileId);
    bool End_asyncCheckpoint(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Used to cache a block into Alluxio space, worker will move the temporary block file from session
    /// folder to data folder, and update the space usage information related. then update the block
    /// information to master.
    /// </summary>
    /// <param name="sessionId">the id of the current session</param>
    /// <param name="blockId">the id of the block being accessed</param>
    void cacheBlock(long sessionId, long blockId);
    #if SILVERLIGHT
    IAsyncResult Begin_cacheBlock(AsyncCallback callback, object state, long sessionId, long blockId);
    void End_cacheBlock(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Used to cancel a block which is being written. worker will delete the temporary block file and
    /// the location and space information related, then reclaim space allocated to the block.
    /// </summary>
    /// <param name="sessionId">the id of the current session</param>
    /// <param name="blockId">the id of the block being accessed</param>
    void cancelBlock(long sessionId, long blockId);
    #if SILVERLIGHT
    IAsyncResult Begin_cancelBlock(AsyncCallback callback, object state, long sessionId, long blockId);
    void End_cancelBlock(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Locks the file in Alluxio's space while the session is reading it. If lock succeeds, the path of
    /// the block's file along with the internal lock id of locked block will be returned. If the block's file
    /// is not found, FileDoesNotExistException will be thrown.
    /// </summary>
    /// <param name="blockId">the id of the block being accessed</param>
    /// <param name="sessionId">the id of the current session</param>
    LockBlockResult lockBlock(long blockId, long sessionId);
    #if SILVERLIGHT
    IAsyncResult Begin_lockBlock(AsyncCallback callback, object state, long blockId, long sessionId);
    LockBlockResult End_lockBlock(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Used to promote block on under storage layer to top storage layer when there are more than one
    /// storage layers in Alluxio's space. return true if the block is successfully promoted, false
    /// otherwise.
    /// </summary>
    /// <param name="blockId">the id of the block being accessed</param>
    bool promoteBlock(long blockId);
    #if SILVERLIGHT
    IAsyncResult Begin_promoteBlock(AsyncCallback callback, object state, long blockId);
    bool End_promoteBlock(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Used to allocate location and space for a new coming block, worker will choose the appropriate
    /// storage directory which fits the initial block size by some allocation strategy, and the
    /// temporary file path of the block file will be returned. if there is no enough space on Alluxio
    /// storage OutOfSpaceException will be thrown, if the file is already being written by the session,
    /// FileAlreadyExistsException will be thrown.
    /// </summary>
    /// <param name="sessionId">the id of the current session</param>
    /// <param name="blockId">the id of the block being accessed</param>
    /// <param name="initialBytes">initial number of bytes requested</param>
    string requestBlockLocation(long sessionId, long blockId, long initialBytes);
    #if SILVERLIGHT
    IAsyncResult Begin_requestBlockLocation(AsyncCallback callback, object state, long sessionId, long blockId, long initialBytes);
    string End_requestBlockLocation(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Used to request space for some block file. return true if the worker successfully allocates
    /// space for the block on block’s location, false if there is no enough space, if there is no
    /// information of the block on worker, FileDoesNotExistException will be thrown.
    /// </summary>
    /// <param name="sessionId">the id of the current session</param>
    /// <param name="blockId">the id of the block being accessed</param>
    /// <param name="requestBytes">the number of bytes requested</param>
    bool requestSpace(long sessionId, long blockId, long requestBytes);
    #if SILVERLIGHT
    IAsyncResult Begin_requestSpace(AsyncCallback callback, object state, long sessionId, long blockId, long requestBytes);
    bool End_requestSpace(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Local session send heartbeat to local worker to keep its temporary folder. It also sends client
    /// metrics to the worker.
    /// </summary>
    /// <param name="sessionId">the id of the current session</param>
    /// <param name="metrics">the client metrics</param>
    void sessionHeartbeat(long sessionId, List<long> metrics);
    #if SILVERLIGHT
    IAsyncResult Begin_sessionHeartbeat(AsyncCallback callback, object state, long sessionId, List<long> metrics);
    void End_sessionHeartbeat(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Used to unlock a block after the block is accessed, if the block is to be removed, delete the
    /// block file. return true if successfully unlock the block, return false if the block is not
    /// found or failed to delete the block.
    /// </summary>
    /// <param name="blockId">the id of the block being accessed</param>
    /// <param name="sessionId">the id of the current session</param>
    bool unlockBlock(long blockId, long sessionId);
    #if SILVERLIGHT
    IAsyncResult Begin_unlockBlock(AsyncCallback callback, object state, long blockId, long sessionId);
    bool End_unlockBlock(IAsyncResult asyncResult);
    #endif
  }

  public class Client : AlluxioService.Client, Iface {
    public Client(TProtocol prot) : this(prot, prot)
    {
    }

    public Client(TProtocol iprot, TProtocol oprot) : base(iprot, oprot)
    {
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_accessBlock(AsyncCallback callback, object state, long blockId)
    {
      return send_accessBlock(callback, state, blockId);
    }

    public void End_accessBlock(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_accessBlock();
    }

    #endif

    /// <summary>
    /// Accesses a block given the block id.
    /// </summary>
    /// <param name="blockId">the id of the block being accessed</param>
    public void accessBlock(long blockId)
    {
      #if !SILVERLIGHT
      send_accessBlock(blockId);
      recv_accessBlock();

      #else
      var asyncResult = Begin_accessBlock(null, null, blockId);
      End_accessBlock(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_accessBlock(AsyncCallback callback, object state, long blockId)
    #else
    public void send_accessBlock(long blockId)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("accessBlock", TMessageType.Call, seqid_));
      accessBlock_args args = new accessBlock_args();
      args.BlockId = blockId;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_accessBlock()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      accessBlock_result result = new accessBlock_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_asyncCheckpoint(AsyncCallback callback, object state, long fileId)
    {
      return send_asyncCheckpoint(callback, state, fileId);
    }

    public bool End_asyncCheckpoint(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_asyncCheckpoint();
    }

    #endif

    /// <summary>
    /// Asynchronously checkpoints a file: returns whether the checkpoint operation succeeded.
    /// </summary>
    /// <param name="fileId">the id of the file being accessed</param>
    public bool asyncCheckpoint(long fileId)
    {
      #if !SILVERLIGHT
      send_asyncCheckpoint(fileId);
      return recv_asyncCheckpoint();

      #else
      var asyncResult = Begin_asyncCheckpoint(null, null, fileId);
      return End_asyncCheckpoint(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_asyncCheckpoint(AsyncCallback callback, object state, long fileId)
    #else
    public void send_asyncCheckpoint(long fileId)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("asyncCheckpoint", TMessageType.Call, seqid_));
      asyncCheckpoint_args args = new asyncCheckpoint_args();
      args.FileId = fileId;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public bool recv_asyncCheckpoint()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      asyncCheckpoint_result result = new asyncCheckpoint_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "asyncCheckpoint failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_cacheBlock(AsyncCallback callback, object state, long sessionId, long blockId)
    {
      return send_cacheBlock(callback, state, sessionId, blockId);
    }

    public void End_cacheBlock(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_cacheBlock();
    }

    #endif

    /// <summary>
    /// Used to cache a block into Alluxio space, worker will move the temporary block file from session
    /// folder to data folder, and update the space usage information related. then update the block
    /// information to master.
    /// </summary>
    /// <param name="sessionId">the id of the current session</param>
    /// <param name="blockId">the id of the block being accessed</param>
    public void cacheBlock(long sessionId, long blockId)
    {
      #if !SILVERLIGHT
      send_cacheBlock(sessionId, blockId);
      recv_cacheBlock();

      #else
      var asyncResult = Begin_cacheBlock(null, null, sessionId, blockId);
      End_cacheBlock(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_cacheBlock(AsyncCallback callback, object state, long sessionId, long blockId)
    #else
    public void send_cacheBlock(long sessionId, long blockId)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("cacheBlock", TMessageType.Call, seqid_));
      cacheBlock_args args = new cacheBlock_args();
      args.SessionId = sessionId;
      args.BlockId = blockId;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_cacheBlock()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      cacheBlock_result result = new cacheBlock_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      if (result.__isset.ioe) {
        throw result.Ioe;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_cancelBlock(AsyncCallback callback, object state, long sessionId, long blockId)
    {
      return send_cancelBlock(callback, state, sessionId, blockId);
    }

    public void End_cancelBlock(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_cancelBlock();
    }

    #endif

    /// <summary>
    /// Used to cancel a block which is being written. worker will delete the temporary block file and
    /// the location and space information related, then reclaim space allocated to the block.
    /// </summary>
    /// <param name="sessionId">the id of the current session</param>
    /// <param name="blockId">the id of the block being accessed</param>
    public void cancelBlock(long sessionId, long blockId)
    {
      #if !SILVERLIGHT
      send_cancelBlock(sessionId, blockId);
      recv_cancelBlock();

      #else
      var asyncResult = Begin_cancelBlock(null, null, sessionId, blockId);
      End_cancelBlock(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_cancelBlock(AsyncCallback callback, object state, long sessionId, long blockId)
    #else
    public void send_cancelBlock(long sessionId, long blockId)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("cancelBlock", TMessageType.Call, seqid_));
      cancelBlock_args args = new cancelBlock_args();
      args.SessionId = sessionId;
      args.BlockId = blockId;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_cancelBlock()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      cancelBlock_result result = new cancelBlock_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      if (result.__isset.ioe) {
        throw result.Ioe;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_lockBlock(AsyncCallback callback, object state, long blockId, long sessionId)
    {
      return send_lockBlock(callback, state, blockId, sessionId);
    }

    public LockBlockResult End_lockBlock(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_lockBlock();
    }

    #endif

    /// <summary>
    /// Locks the file in Alluxio's space while the session is reading it. If lock succeeds, the path of
    /// the block's file along with the internal lock id of locked block will be returned. If the block's file
    /// is not found, FileDoesNotExistException will be thrown.
    /// </summary>
    /// <param name="blockId">the id of the block being accessed</param>
    /// <param name="sessionId">the id of the current session</param>
    public LockBlockResult lockBlock(long blockId, long sessionId)
    {
      #if !SILVERLIGHT
      send_lockBlock(blockId, sessionId);
      return recv_lockBlock();

      #else
      var asyncResult = Begin_lockBlock(null, null, blockId, sessionId);
      return End_lockBlock(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_lockBlock(AsyncCallback callback, object state, long blockId, long sessionId)
    #else
    public void send_lockBlock(long blockId, long sessionId)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("lockBlock", TMessageType.Call, seqid_));
      lockBlock_args args = new lockBlock_args();
      args.BlockId = blockId;
      args.SessionId = sessionId;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public LockBlockResult recv_lockBlock()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      lockBlock_result result = new lockBlock_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "lockBlock failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_promoteBlock(AsyncCallback callback, object state, long blockId)
    {
      return send_promoteBlock(callback, state, blockId);
    }

    public bool End_promoteBlock(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_promoteBlock();
    }

    #endif

    /// <summary>
    /// Used to promote block on under storage layer to top storage layer when there are more than one
    /// storage layers in Alluxio's space. return true if the block is successfully promoted, false
    /// otherwise.
    /// </summary>
    /// <param name="blockId">the id of the block being accessed</param>
    public bool promoteBlock(long blockId)
    {
      #if !SILVERLIGHT
      send_promoteBlock(blockId);
      return recv_promoteBlock();

      #else
      var asyncResult = Begin_promoteBlock(null, null, blockId);
      return End_promoteBlock(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_promoteBlock(AsyncCallback callback, object state, long blockId)
    #else
    public void send_promoteBlock(long blockId)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("promoteBlock", TMessageType.Call, seqid_));
      promoteBlock_args args = new promoteBlock_args();
      args.BlockId = blockId;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public bool recv_promoteBlock()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      promoteBlock_result result = new promoteBlock_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      if (result.__isset.ioe) {
        throw result.Ioe;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "promoteBlock failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_requestBlockLocation(AsyncCallback callback, object state, long sessionId, long blockId, long initialBytes)
    {
      return send_requestBlockLocation(callback, state, sessionId, blockId, initialBytes);
    }

    public string End_requestBlockLocation(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_requestBlockLocation();
    }

    #endif

    /// <summary>
    /// Used to allocate location and space for a new coming block, worker will choose the appropriate
    /// storage directory which fits the initial block size by some allocation strategy, and the
    /// temporary file path of the block file will be returned. if there is no enough space on Alluxio
    /// storage OutOfSpaceException will be thrown, if the file is already being written by the session,
    /// FileAlreadyExistsException will be thrown.
    /// </summary>
    /// <param name="sessionId">the id of the current session</param>
    /// <param name="blockId">the id of the block being accessed</param>
    /// <param name="initialBytes">initial number of bytes requested</param>
    public string requestBlockLocation(long sessionId, long blockId, long initialBytes)
    {
      #if !SILVERLIGHT
      send_requestBlockLocation(sessionId, blockId, initialBytes);
      return recv_requestBlockLocation();

      #else
      var asyncResult = Begin_requestBlockLocation(null, null, sessionId, blockId, initialBytes);
      return End_requestBlockLocation(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_requestBlockLocation(AsyncCallback callback, object state, long sessionId, long blockId, long initialBytes)
    #else
    public void send_requestBlockLocation(long sessionId, long blockId, long initialBytes)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("requestBlockLocation", TMessageType.Call, seqid_));
      requestBlockLocation_args args = new requestBlockLocation_args();
      args.SessionId = sessionId;
      args.BlockId = blockId;
      args.InitialBytes = initialBytes;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public string recv_requestBlockLocation()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      requestBlockLocation_result result = new requestBlockLocation_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      if (result.__isset.ioe) {
        throw result.Ioe;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "requestBlockLocation failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_requestSpace(AsyncCallback callback, object state, long sessionId, long blockId, long requestBytes)
    {
      return send_requestSpace(callback, state, sessionId, blockId, requestBytes);
    }

    public bool End_requestSpace(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_requestSpace();
    }

    #endif

    /// <summary>
    /// Used to request space for some block file. return true if the worker successfully allocates
    /// space for the block on block’s location, false if there is no enough space, if there is no
    /// information of the block on worker, FileDoesNotExistException will be thrown.
    /// </summary>
    /// <param name="sessionId">the id of the current session</param>
    /// <param name="blockId">the id of the block being accessed</param>
    /// <param name="requestBytes">the number of bytes requested</param>
    public bool requestSpace(long sessionId, long blockId, long requestBytes)
    {
      #if !SILVERLIGHT
      send_requestSpace(sessionId, blockId, requestBytes);
      return recv_requestSpace();

      #else
      var asyncResult = Begin_requestSpace(null, null, sessionId, blockId, requestBytes);
      return End_requestSpace(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_requestSpace(AsyncCallback callback, object state, long sessionId, long blockId, long requestBytes)
    #else
    public void send_requestSpace(long sessionId, long blockId, long requestBytes)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("requestSpace", TMessageType.Call, seqid_));
      requestSpace_args args = new requestSpace_args();
      args.SessionId = sessionId;
      args.BlockId = blockId;
      args.RequestBytes = requestBytes;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public bool recv_requestSpace()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      requestSpace_result result = new requestSpace_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "requestSpace failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_sessionHeartbeat(AsyncCallback callback, object state, long sessionId, List<long> metrics)
    {
      return send_sessionHeartbeat(callback, state, sessionId, metrics);
    }

    public void End_sessionHeartbeat(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_sessionHeartbeat();
    }

    #endif

    /// <summary>
    /// Local session send heartbeat to local worker to keep its temporary folder. It also sends client
    /// metrics to the worker.
    /// </summary>
    /// <param name="sessionId">the id of the current session</param>
    /// <param name="metrics">the client metrics</param>
    public void sessionHeartbeat(long sessionId, List<long> metrics)
    {
      #if !SILVERLIGHT
      send_sessionHeartbeat(sessionId, metrics);
      recv_sessionHeartbeat();

      #else
      var asyncResult = Begin_sessionHeartbeat(null, null, sessionId, metrics);
      End_sessionHeartbeat(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_sessionHeartbeat(AsyncCallback callback, object state, long sessionId, List<long> metrics)
    #else
    public void send_sessionHeartbeat(long sessionId, List<long> metrics)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("sessionHeartbeat", TMessageType.Call, seqid_));
      sessionHeartbeat_args args = new sessionHeartbeat_args();
      args.SessionId = sessionId;
      args.Metrics = metrics;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_sessionHeartbeat()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      sessionHeartbeat_result result = new sessionHeartbeat_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_unlockBlock(AsyncCallback callback, object state, long blockId, long sessionId)
    {
      return send_unlockBlock(callback, state, blockId, sessionId);
    }

    public bool End_unlockBlock(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_unlockBlock();
    }

    #endif

    /// <summary>
    /// Used to unlock a block after the block is accessed, if the block is to be removed, delete the
    /// block file. return true if successfully unlock the block, return false if the block is not
    /// found or failed to delete the block.
    /// </summary>
    /// <param name="blockId">the id of the block being accessed</param>
    /// <param name="sessionId">the id of the current session</param>
    public bool unlockBlock(long blockId, long sessionId)
    {
      #if !SILVERLIGHT
      send_unlockBlock(blockId, sessionId);
      return recv_unlockBlock();

      #else
      var asyncResult = Begin_unlockBlock(null, null, blockId, sessionId);
      return End_unlockBlock(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_unlockBlock(AsyncCallback callback, object state, long blockId, long sessionId)
    #else
    public void send_unlockBlock(long blockId, long sessionId)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("unlockBlock", TMessageType.Call, seqid_));
      unlockBlock_args args = new unlockBlock_args();
      args.BlockId = blockId;
      args.SessionId = sessionId;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public bool recv_unlockBlock()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      unlockBlock_result result = new unlockBlock_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "unlockBlock failed: unknown result");
    }

  }
  public class Processor : AlluxioService.Processor, TProcessor {
    public Processor(Iface iface) : base(iface)
    {
      iface_ = iface;
      processMap_["accessBlock"] = accessBlock_Process;
      processMap_["asyncCheckpoint"] = asyncCheckpoint_Process;
      processMap_["cacheBlock"] = cacheBlock_Process;
      processMap_["cancelBlock"] = cancelBlock_Process;
      processMap_["lockBlock"] = lockBlock_Process;
      processMap_["promoteBlock"] = promoteBlock_Process;
      processMap_["requestBlockLocation"] = requestBlockLocation_Process;
      processMap_["requestSpace"] = requestSpace_Process;
      processMap_["sessionHeartbeat"] = sessionHeartbeat_Process;
      processMap_["unlockBlock"] = unlockBlock_Process;
    }

    private Iface iface_;

    public new bool Process(TProtocol iprot, TProtocol oprot)
    {
      try
      {
        TMessage msg = iprot.ReadMessageBegin();
        ProcessFunction fn;
        processMap_.TryGetValue(msg.Name, out fn);
        if (fn == null) {
          TProtocolUtil.Skip(iprot, TType.Struct);
          iprot.ReadMessageEnd();
          TApplicationException x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
          oprot.WriteMessageBegin(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID));
          x.Write(oprot);
          oprot.WriteMessageEnd();
          oprot.Transport.Flush();
          return true;
        }
        fn(msg.SeqID, iprot, oprot);
      }
      catch (IOException)
      {
        return false;
      }
      return true;
    }

    public void accessBlock_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      accessBlock_args args = new accessBlock_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      accessBlock_result result = new accessBlock_result();
      iface_.accessBlock(args.BlockId);
      oprot.WriteMessageBegin(new TMessage("accessBlock", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void asyncCheckpoint_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      asyncCheckpoint_args args = new asyncCheckpoint_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      asyncCheckpoint_result result = new asyncCheckpoint_result();
      try {
        result.Success = iface_.asyncCheckpoint(args.FileId);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("asyncCheckpoint", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void cacheBlock_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      cacheBlock_args args = new cacheBlock_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      cacheBlock_result result = new cacheBlock_result();
      try {
        iface_.cacheBlock(args.SessionId, args.BlockId);
      } catch (AlluxioTException e) {
        result.E = e;
      } catch (ThriftIOException ioe) {
        result.Ioe = ioe;
      }
      oprot.WriteMessageBegin(new TMessage("cacheBlock", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void cancelBlock_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      cancelBlock_args args = new cancelBlock_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      cancelBlock_result result = new cancelBlock_result();
      try {
        iface_.cancelBlock(args.SessionId, args.BlockId);
      } catch (AlluxioTException e) {
        result.E = e;
      } catch (ThriftIOException ioe) {
        result.Ioe = ioe;
      }
      oprot.WriteMessageBegin(new TMessage("cancelBlock", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void lockBlock_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      lockBlock_args args = new lockBlock_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      lockBlock_result result = new lockBlock_result();
      try {
        result.Success = iface_.lockBlock(args.BlockId, args.SessionId);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("lockBlock", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void promoteBlock_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      promoteBlock_args args = new promoteBlock_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      promoteBlock_result result = new promoteBlock_result();
      try {
        result.Success = iface_.promoteBlock(args.BlockId);
      } catch (AlluxioTException e) {
        result.E = e;
      } catch (ThriftIOException ioe) {
        result.Ioe = ioe;
      }
      oprot.WriteMessageBegin(new TMessage("promoteBlock", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void requestBlockLocation_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      requestBlockLocation_args args = new requestBlockLocation_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      requestBlockLocation_result result = new requestBlockLocation_result();
      try {
        result.Success = iface_.requestBlockLocation(args.SessionId, args.BlockId, args.InitialBytes);
      } catch (AlluxioTException e) {
        result.E = e;
      } catch (ThriftIOException ioe) {
        result.Ioe = ioe;
      }
      oprot.WriteMessageBegin(new TMessage("requestBlockLocation", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void requestSpace_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      requestSpace_args args = new requestSpace_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      requestSpace_result result = new requestSpace_result();
      try {
        result.Success = iface_.requestSpace(args.SessionId, args.BlockId, args.RequestBytes);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("requestSpace", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void sessionHeartbeat_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      sessionHeartbeat_args args = new sessionHeartbeat_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      sessionHeartbeat_result result = new sessionHeartbeat_result();
      iface_.sessionHeartbeat(args.SessionId, args.Metrics);
      oprot.WriteMessageBegin(new TMessage("sessionHeartbeat", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void unlockBlock_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      unlockBlock_args args = new unlockBlock_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      unlockBlock_result result = new unlockBlock_result();
      result.Success = iface_.unlockBlock(args.BlockId, args.SessionId);
      oprot.WriteMessageBegin(new TMessage("unlockBlock", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class accessBlock_args : TBase
  {
    private long _blockId;

    /// <summary>
    /// the id of the block being accessed
    /// </summary>
    public long BlockId
    {
      get
      {
        return _blockId;
      }
      set
      {
        __isset.blockId = true;
        this._blockId = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool blockId;
    }

    public accessBlock_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                BlockId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("accessBlock_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.blockId) {
          field.Name = "blockId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(BlockId);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("accessBlock_args(");
      bool __first = true;
      if (__isset.blockId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("BlockId: ");
        __sb.Append(BlockId);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class accessBlock_result : TBase
  {

    public accessBlock_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("accessBlock_result");
        oprot.WriteStructBegin(struc);

        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("accessBlock_result(");
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class asyncCheckpoint_args : TBase
  {
    private long _fileId;

    /// <summary>
    /// the id of the file being accessed
    /// </summary>
    public long FileId
    {
      get
      {
        return _fileId;
      }
      set
      {
        __isset.fileId = true;
        this._fileId = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool fileId;
    }

    public asyncCheckpoint_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                FileId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("asyncCheckpoint_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.fileId) {
          field.Name = "fileId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(FileId);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("asyncCheckpoint_args(");
      bool __first = true;
      if (__isset.fileId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("FileId: ");
        __sb.Append(FileId);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class asyncCheckpoint_result : TBase
  {
    private bool _success;
    private AlluxioTException _e;

    public bool Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
    }

    public asyncCheckpoint_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Bool) {
                Success = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("asyncCheckpoint_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          field.Name = "Success";
          field.Type = TType.Bool;
          field.ID = 0;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(Success);
          oprot.WriteFieldEnd();
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("asyncCheckpoint_result(");
      bool __first = true;
      if (__isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success);
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class cacheBlock_args : TBase
  {
    private long _sessionId;
    private long _blockId;

    /// <summary>
    /// the id of the current session
    /// </summary>
    public long SessionId
    {
      get
      {
        return _sessionId;
      }
      set
      {
        __isset.sessionId = true;
        this._sessionId = value;
      }
    }

    /// <summary>
    /// the id of the block being accessed
    /// </summary>
    public long BlockId
    {
      get
      {
        return _blockId;
      }
      set
      {
        __isset.blockId = true;
        this._blockId = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool sessionId;
      public bool blockId;
    }

    public cacheBlock_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                SessionId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.I64) {
                BlockId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("cacheBlock_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.sessionId) {
          field.Name = "sessionId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(SessionId);
          oprot.WriteFieldEnd();
        }
        if (__isset.blockId) {
          field.Name = "blockId";
          field.Type = TType.I64;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(BlockId);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("cacheBlock_args(");
      bool __first = true;
      if (__isset.sessionId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SessionId: ");
        __sb.Append(SessionId);
      }
      if (__isset.blockId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("BlockId: ");
        __sb.Append(BlockId);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class cacheBlock_result : TBase
  {
    private AlluxioTException _e;
    private ThriftIOException _ioe;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }

    public ThriftIOException Ioe
    {
      get
      {
        return _ioe;
      }
      set
      {
        __isset.ioe = true;
        this._ioe = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
      public bool ioe;
    }

    public cacheBlock_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Ioe = new ThriftIOException();
                Ioe.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("cacheBlock_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.ioe) {
          if (Ioe != null) {
            field.Name = "Ioe";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Ioe.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("cacheBlock_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      if (Ioe != null && __isset.ioe) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ioe: ");
        __sb.Append(Ioe== null ? "<null>" : Ioe.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class cancelBlock_args : TBase
  {
    private long _sessionId;
    private long _blockId;

    /// <summary>
    /// the id of the current session
    /// </summary>
    public long SessionId
    {
      get
      {
        return _sessionId;
      }
      set
      {
        __isset.sessionId = true;
        this._sessionId = value;
      }
    }

    /// <summary>
    /// the id of the block being accessed
    /// </summary>
    public long BlockId
    {
      get
      {
        return _blockId;
      }
      set
      {
        __isset.blockId = true;
        this._blockId = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool sessionId;
      public bool blockId;
    }

    public cancelBlock_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                SessionId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.I64) {
                BlockId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("cancelBlock_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.sessionId) {
          field.Name = "sessionId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(SessionId);
          oprot.WriteFieldEnd();
        }
        if (__isset.blockId) {
          field.Name = "blockId";
          field.Type = TType.I64;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(BlockId);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("cancelBlock_args(");
      bool __first = true;
      if (__isset.sessionId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SessionId: ");
        __sb.Append(SessionId);
      }
      if (__isset.blockId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("BlockId: ");
        __sb.Append(BlockId);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class cancelBlock_result : TBase
  {
    private AlluxioTException _e;
    private ThriftIOException _ioe;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }

    public ThriftIOException Ioe
    {
      get
      {
        return _ioe;
      }
      set
      {
        __isset.ioe = true;
        this._ioe = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
      public bool ioe;
    }

    public cancelBlock_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Ioe = new ThriftIOException();
                Ioe.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("cancelBlock_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.ioe) {
          if (Ioe != null) {
            field.Name = "Ioe";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Ioe.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("cancelBlock_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      if (Ioe != null && __isset.ioe) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ioe: ");
        __sb.Append(Ioe== null ? "<null>" : Ioe.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class lockBlock_args : TBase
  {
    private long _blockId;
    private long _sessionId;

    /// <summary>
    /// the id of the block being accessed
    /// </summary>
    public long BlockId
    {
      get
      {
        return _blockId;
      }
      set
      {
        __isset.blockId = true;
        this._blockId = value;
      }
    }

    /// <summary>
    /// the id of the current session
    /// </summary>
    public long SessionId
    {
      get
      {
        return _sessionId;
      }
      set
      {
        __isset.sessionId = true;
        this._sessionId = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool blockId;
      public bool sessionId;
    }

    public lockBlock_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                BlockId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.I64) {
                SessionId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("lockBlock_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.blockId) {
          field.Name = "blockId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(BlockId);
          oprot.WriteFieldEnd();
        }
        if (__isset.sessionId) {
          field.Name = "sessionId";
          field.Type = TType.I64;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(SessionId);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("lockBlock_args(");
      bool __first = true;
      if (__isset.blockId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("BlockId: ");
        __sb.Append(BlockId);
      }
      if (__isset.sessionId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SessionId: ");
        __sb.Append(SessionId);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class lockBlock_result : TBase
  {
    private LockBlockResult _success;
    private AlluxioTException _e;

    public LockBlockResult Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
    }

    public lockBlock_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Struct) {
                Success = new LockBlockResult();
                Success.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("lockBlock_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          if (Success != null) {
            field.Name = "Success";
            field.Type = TType.Struct;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            Success.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("lockBlock_result(");
      bool __first = true;
      if (Success != null && __isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success== null ? "<null>" : Success.ToString());
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class promoteBlock_args : TBase
  {
    private long _blockId;

    /// <summary>
    /// the id of the block being accessed
    /// </summary>
    public long BlockId
    {
      get
      {
        return _blockId;
      }
      set
      {
        __isset.blockId = true;
        this._blockId = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool blockId;
    }

    public promoteBlock_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                BlockId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("promoteBlock_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.blockId) {
          field.Name = "blockId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(BlockId);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("promoteBlock_args(");
      bool __first = true;
      if (__isset.blockId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("BlockId: ");
        __sb.Append(BlockId);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class promoteBlock_result : TBase
  {
    private bool _success;
    private AlluxioTException _e;
    private ThriftIOException _ioe;

    public bool Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }

    public ThriftIOException Ioe
    {
      get
      {
        return _ioe;
      }
      set
      {
        __isset.ioe = true;
        this._ioe = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
      public bool ioe;
    }

    public promoteBlock_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Bool) {
                Success = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Ioe = new ThriftIOException();
                Ioe.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("promoteBlock_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          field.Name = "Success";
          field.Type = TType.Bool;
          field.ID = 0;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(Success);
          oprot.WriteFieldEnd();
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.ioe) {
          if (Ioe != null) {
            field.Name = "Ioe";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Ioe.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("promoteBlock_result(");
      bool __first = true;
      if (__isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success);
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      if (Ioe != null && __isset.ioe) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ioe: ");
        __sb.Append(Ioe== null ? "<null>" : Ioe.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class requestBlockLocation_args : TBase
  {
    private long _sessionId;
    private long _blockId;
    private long _initialBytes;

    /// <summary>
    /// the id of the current session
    /// </summary>
    public long SessionId
    {
      get
      {
        return _sessionId;
      }
      set
      {
        __isset.sessionId = true;
        this._sessionId = value;
      }
    }

    /// <summary>
    /// the id of the block being accessed
    /// </summary>
    public long BlockId
    {
      get
      {
        return _blockId;
      }
      set
      {
        __isset.blockId = true;
        this._blockId = value;
      }
    }

    /// <summary>
    /// initial number of bytes requested
    /// </summary>
    public long InitialBytes
    {
      get
      {
        return _initialBytes;
      }
      set
      {
        __isset.initialBytes = true;
        this._initialBytes = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool sessionId;
      public bool blockId;
      public bool initialBytes;
    }

    public requestBlockLocation_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                SessionId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.I64) {
                BlockId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 3:
              if (field.Type == TType.I64) {
                InitialBytes = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("requestBlockLocation_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.sessionId) {
          field.Name = "sessionId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(SessionId);
          oprot.WriteFieldEnd();
        }
        if (__isset.blockId) {
          field.Name = "blockId";
          field.Type = TType.I64;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(BlockId);
          oprot.WriteFieldEnd();
        }
        if (__isset.initialBytes) {
          field.Name = "initialBytes";
          field.Type = TType.I64;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(InitialBytes);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("requestBlockLocation_args(");
      bool __first = true;
      if (__isset.sessionId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SessionId: ");
        __sb.Append(SessionId);
      }
      if (__isset.blockId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("BlockId: ");
        __sb.Append(BlockId);
      }
      if (__isset.initialBytes) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("InitialBytes: ");
        __sb.Append(InitialBytes);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class requestBlockLocation_result : TBase
  {
    private string _success;
    private AlluxioTException _e;
    private ThriftIOException _ioe;

    public string Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }

    public ThriftIOException Ioe
    {
      get
      {
        return _ioe;
      }
      set
      {
        __isset.ioe = true;
        this._ioe = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
      public bool ioe;
    }

    public requestBlockLocation_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.String) {
                Success = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Ioe = new ThriftIOException();
                Ioe.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("requestBlockLocation_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          if (Success != null) {
            field.Name = "Success";
            field.Type = TType.String;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Success);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.ioe) {
          if (Ioe != null) {
            field.Name = "Ioe";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Ioe.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("requestBlockLocation_result(");
      bool __first = true;
      if (Success != null && __isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success);
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      if (Ioe != null && __isset.ioe) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ioe: ");
        __sb.Append(Ioe== null ? "<null>" : Ioe.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class requestSpace_args : TBase
  {
    private long _sessionId;
    private long _blockId;
    private long _requestBytes;

    /// <summary>
    /// the id of the current session
    /// </summary>
    public long SessionId
    {
      get
      {
        return _sessionId;
      }
      set
      {
        __isset.sessionId = true;
        this._sessionId = value;
      }
    }

    /// <summary>
    /// the id of the block being accessed
    /// </summary>
    public long BlockId
    {
      get
      {
        return _blockId;
      }
      set
      {
        __isset.blockId = true;
        this._blockId = value;
      }
    }

    /// <summary>
    /// the number of bytes requested
    /// </summary>
    public long RequestBytes
    {
      get
      {
        return _requestBytes;
      }
      set
      {
        __isset.requestBytes = true;
        this._requestBytes = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool sessionId;
      public bool blockId;
      public bool requestBytes;
    }

    public requestSpace_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                SessionId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.I64) {
                BlockId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 3:
              if (field.Type == TType.I64) {
                RequestBytes = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("requestSpace_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.sessionId) {
          field.Name = "sessionId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(SessionId);
          oprot.WriteFieldEnd();
        }
        if (__isset.blockId) {
          field.Name = "blockId";
          field.Type = TType.I64;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(BlockId);
          oprot.WriteFieldEnd();
        }
        if (__isset.requestBytes) {
          field.Name = "requestBytes";
          field.Type = TType.I64;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(RequestBytes);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("requestSpace_args(");
      bool __first = true;
      if (__isset.sessionId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SessionId: ");
        __sb.Append(SessionId);
      }
      if (__isset.blockId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("BlockId: ");
        __sb.Append(BlockId);
      }
      if (__isset.requestBytes) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("RequestBytes: ");
        __sb.Append(RequestBytes);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class requestSpace_result : TBase
  {
    private bool _success;
    private AlluxioTException _e;

    public bool Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
    }

    public requestSpace_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Bool) {
                Success = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("requestSpace_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          field.Name = "Success";
          field.Type = TType.Bool;
          field.ID = 0;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(Success);
          oprot.WriteFieldEnd();
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("requestSpace_result(");
      bool __first = true;
      if (__isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success);
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class sessionHeartbeat_args : TBase
  {
    private long _sessionId;
    private List<long> _metrics;

    /// <summary>
    /// the id of the current session
    /// </summary>
    public long SessionId
    {
      get
      {
        return _sessionId;
      }
      set
      {
        __isset.sessionId = true;
        this._sessionId = value;
      }
    }

    /// <summary>
    /// the client metrics
    /// </summary>
    public List<long> Metrics
    {
      get
      {
        return _metrics;
      }
      set
      {
        __isset.metrics = true;
        this._metrics = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool sessionId;
      public bool metrics;
    }

    public sessionHeartbeat_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                SessionId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.List) {
                {
                  Metrics = new List<long>();
                  TList _list0 = iprot.ReadListBegin();
                  for( int _i1 = 0; _i1 < _list0.Count; ++_i1)
                  {
                    long _elem2;
                    _elem2 = iprot.ReadI64();
                    Metrics.Add(_elem2);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("sessionHeartbeat_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.sessionId) {
          field.Name = "sessionId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(SessionId);
          oprot.WriteFieldEnd();
        }
        if (Metrics != null && __isset.metrics) {
          field.Name = "metrics";
          field.Type = TType.List;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.I64, Metrics.Count));
            foreach (long _iter3 in Metrics)
            {
              oprot.WriteI64(_iter3);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("sessionHeartbeat_args(");
      bool __first = true;
      if (__isset.sessionId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SessionId: ");
        __sb.Append(SessionId);
      }
      if (Metrics != null && __isset.metrics) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Metrics: ");
        __sb.Append(Metrics);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class sessionHeartbeat_result : TBase
  {

    public sessionHeartbeat_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("sessionHeartbeat_result");
        oprot.WriteStructBegin(struc);

        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("sessionHeartbeat_result(");
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class unlockBlock_args : TBase
  {
    private long _blockId;
    private long _sessionId;

    /// <summary>
    /// the id of the block being accessed
    /// </summary>
    public long BlockId
    {
      get
      {
        return _blockId;
      }
      set
      {
        __isset.blockId = true;
        this._blockId = value;
      }
    }

    /// <summary>
    /// the id of the current session
    /// </summary>
    public long SessionId
    {
      get
      {
        return _sessionId;
      }
      set
      {
        __isset.sessionId = true;
        this._sessionId = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool blockId;
      public bool sessionId;
    }

    public unlockBlock_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                BlockId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.I64) {
                SessionId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("unlockBlock_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.blockId) {
          field.Name = "blockId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(BlockId);
          oprot.WriteFieldEnd();
        }
        if (__isset.sessionId) {
          field.Name = "sessionId";
          field.Type = TType.I64;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(SessionId);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("unlockBlock_args(");
      bool __first = true;
      if (__isset.blockId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("BlockId: ");
        __sb.Append(BlockId);
      }
      if (__isset.sessionId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SessionId: ");
        __sb.Append(SessionId);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class unlockBlock_result : TBase
  {
    private bool _success;

    public bool Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
    }

    public unlockBlock_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Bool) {
                Success = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("unlockBlock_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          field.Name = "Success";
          field.Type = TType.Bool;
          field.ID = 0;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(Success);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("unlockBlock_result(");
      bool __first = true;
      if (__isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }

}
