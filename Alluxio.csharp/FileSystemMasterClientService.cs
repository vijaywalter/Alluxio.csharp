/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

public partial class FileSystemMasterClientService {
  /// <summary>
  /// This interface contains file system master service endpoints for Alluxio clients.
  /// </summary>
  public interface Iface : AlluxioService.Iface {
    /// <summary>
    /// Marks a file as completed.
    /// </summary>
    /// <param name="path">the path of the file</param>
    /// <param name="options">the method options</param>
    void completeFile(string path, CompleteFileTOptions options);
    #if SILVERLIGHT
    IAsyncResult Begin_completeFile(AsyncCallback callback, object state, string path, CompleteFileTOptions options);
    void End_completeFile(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Creates a directory.
    /// </summary>
    /// <param name="path">the path of the directory</param>
    /// <param name="options">the method options</param>
    void createDirectory(string path, CreateDirectoryTOptions options);
    #if SILVERLIGHT
    IAsyncResult Begin_createDirectory(AsyncCallback callback, object state, string path, CreateDirectoryTOptions options);
    void End_createDirectory(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Creates a file.
    /// </summary>
    /// <param name="path">the path of the file</param>
    /// <param name="options">the options for creating the file</param>
    void createFile(string path, CreateFileTOptions options);
    #if SILVERLIGHT
    IAsyncResult Begin_createFile(AsyncCallback callback, object state, string path, CreateFileTOptions options);
    void End_createFile(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Frees the given file or directory from Alluxio.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    /// <param name="recursive">whether to free recursively</param>
    void free(string path, bool recursive);
    #if SILVERLIGHT
    IAsyncResult Begin_free(AsyncCallback callback, object state, string path, bool recursive);
    void End_free(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Returns the list of file blocks information for the given file.
    /// 
    /// THIS METHOD IS DEPRECATED SINCE VERSION 1.1 AND WILL BE REMOVED IN VERSION 2.0.
    /// </summary>
    /// <param name="path">the path of the file</param>
    List<FileBlockInfo> getFileBlockInfoList(string path);
    #if SILVERLIGHT
    IAsyncResult Begin_getFileBlockInfoList(AsyncCallback callback, object state, string path);
    List<FileBlockInfo> End_getFileBlockInfoList(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Returns the status of the file or directory.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    FileInfo getStatus(string path);
    #if SILVERLIGHT
    IAsyncResult Begin_getStatus(AsyncCallback callback, object state, string path);
    FileInfo End_getStatus(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Returns the status of the file or directory, only used internally by servers.
    /// 
    /// THIS METHOD IS DEPRECATED SINCE VERSION 1.1 AND WILL BE REMOVED IN VERSION 2.0.
    /// </summary>
    /// <param name="fileId">the id of the file or directory</param>
    FileInfo getStatusInternal(long fileId);
    #if SILVERLIGHT
    IAsyncResult Begin_getStatusInternal(AsyncCallback callback, object state, long fileId);
    FileInfo End_getStatusInternal(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Generates a new block id for the given file.
    /// </summary>
    /// <param name="path">the path of the file</param>
    long getNewBlockIdForFile(string path);
    #if SILVERLIGHT
    IAsyncResult Begin_getNewBlockIdForFile(AsyncCallback callback, object state, string path);
    long End_getNewBlockIdForFile(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Returns the UFS address of the root mount point.
    /// 
    /// THIS METHOD IS DEPRECATED SINCE VERSION 1.1 AND WILL BE REMOVED IN VERSION 2.0.
    /// </summary>
    string getUfsAddress();
    #if SILVERLIGHT
    IAsyncResult Begin_getUfsAddress(AsyncCallback callback, object state);
    string End_getUfsAddress(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// If the path points to a file, the method returns a singleton with its file information.
    /// If the path points to a directory, the method returns a list with file information for the
    /// directory contents.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    /// <param name="options">listStatus options</param>
    List<FileInfo> listStatus(string path, ListStatusTOptions options);
    #if SILVERLIGHT
    IAsyncResult Begin_listStatus(AsyncCallback callback, object state, string path, ListStatusTOptions options);
    List<FileInfo> End_listStatus(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Loads metadata for the object identified by the given Alluxio path from UFS into Alluxio.
    /// 
    /// THIS METHOD IS DEPRECATED SINCE VERSION 1.1 AND WILL BE REMOVED IN VERSION 2.0.
    /// </summary>
    /// <param name="ufsPath">the path of the under file system</param>
    /// <param name="recursive">whether to load meta data recursively</param>
    long loadMetadata(string ufsPath, bool recursive);
    #if SILVERLIGHT
    IAsyncResult Begin_loadMetadata(AsyncCallback callback, object state, string ufsPath, bool recursive);
    long End_loadMetadata(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Creates a new "mount point", mounts the given UFS path in the Alluxio namespace at the given
    /// path. The path should not exist and should not be nested under any existing mount point.
    /// </summary>
    /// <param name="alluxioPath">the path of alluxio mount point</param>
    /// <param name="ufsPath">the path of the under file system</param>
    /// <param name="options">the options for creating the mount point</param>
    void mount(string alluxioPath, string ufsPath, MountTOptions options);
    #if SILVERLIGHT
    IAsyncResult Begin_mount(AsyncCallback callback, object state, string alluxioPath, string ufsPath, MountTOptions options);
    void End_mount(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Deletes a file or a directory and returns whether the remove operation succeeded.
    /// NOTE: Unfortunately, the method cannot be called "delete" as that is a reserved Thrift keyword.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    /// <param name="recursive">whether to remove recursively</param>
    void @remove(string path, bool recursive);
    #if SILVERLIGHT
    IAsyncResult Begin_remove(AsyncCallback callback, object state, string path, bool recursive);
    void End_remove(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Renames a file or a directory.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    /// <param name="dstPath">the desinationpath of the file</param>
    void rename(string path, string dstPath);
    #if SILVERLIGHT
    IAsyncResult Begin_rename(AsyncCallback callback, object state, string path, string dstPath);
    void End_rename(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Sets file or directory attributes.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    /// <param name="options">the method options</param>
    void setAttribute(string path, SetAttributeTOptions options);
    #if SILVERLIGHT
    IAsyncResult Begin_setAttribute(AsyncCallback callback, object state, string path, SetAttributeTOptions options);
    void End_setAttribute(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Schedules async persistence.
    /// </summary>
    /// <param name="path">the path of the file</param>
    void scheduleAsyncPersist(string path);
    #if SILVERLIGHT
    IAsyncResult Begin_scheduleAsyncPersist(AsyncCallback callback, object state, string path);
    void End_scheduleAsyncPersist(IAsyncResult asyncResult);
    #endif
    /// <summary>
    /// Deletes an existing "mount point", voiding the Alluxio namespace at the given path. The path
    /// should correspond to an existing mount point. Any files in its subtree that are backed by UFS
    /// will be persisted before they are removed from the Alluxio namespace.
    /// </summary>
    /// <param name="alluxioPath">the path of the alluxio mount point</param>
    void unmount(string alluxioPath);
    #if SILVERLIGHT
    IAsyncResult Begin_unmount(AsyncCallback callback, object state, string alluxioPath);
    void End_unmount(IAsyncResult asyncResult);
    #endif
  }

  /// <summary>
  /// This interface contains file system master service endpoints for Alluxio clients.
  /// </summary>
  public class Client : AlluxioService.Client, Iface {
    public Client(TProtocol prot) : this(prot, prot)
    {
    }

    public Client(TProtocol iprot, TProtocol oprot) : base(iprot, oprot)
    {
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_completeFile(AsyncCallback callback, object state, string path, CompleteFileTOptions options)
    {
      return send_completeFile(callback, state, path, options);
    }

    public void End_completeFile(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_completeFile();
    }

    #endif

    /// <summary>
    /// Marks a file as completed.
    /// </summary>
    /// <param name="path">the path of the file</param>
    /// <param name="options">the method options</param>
    public void completeFile(string path, CompleteFileTOptions options)
    {
      #if !SILVERLIGHT
      send_completeFile(path, options);
      recv_completeFile();

      #else
      var asyncResult = Begin_completeFile(null, null, path, options);
      End_completeFile(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_completeFile(AsyncCallback callback, object state, string path, CompleteFileTOptions options)
    #else
    public void send_completeFile(string path, CompleteFileTOptions options)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("completeFile", TMessageType.Call, seqid_));
      completeFile_args args = new completeFile_args();
      args.Path = path;
      args.Options = options;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_completeFile()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      completeFile_result result = new completeFile_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_createDirectory(AsyncCallback callback, object state, string path, CreateDirectoryTOptions options)
    {
      return send_createDirectory(callback, state, path, options);
    }

    public void End_createDirectory(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_createDirectory();
    }

    #endif

    /// <summary>
    /// Creates a directory.
    /// </summary>
    /// <param name="path">the path of the directory</param>
    /// <param name="options">the method options</param>
    public void createDirectory(string path, CreateDirectoryTOptions options)
    {
      #if !SILVERLIGHT
      send_createDirectory(path, options);
      recv_createDirectory();

      #else
      var asyncResult = Begin_createDirectory(null, null, path, options);
      End_createDirectory(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_createDirectory(AsyncCallback callback, object state, string path, CreateDirectoryTOptions options)
    #else
    public void send_createDirectory(string path, CreateDirectoryTOptions options)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("createDirectory", TMessageType.Call, seqid_));
      createDirectory_args args = new createDirectory_args();
      args.Path = path;
      args.Options = options;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_createDirectory()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      createDirectory_result result = new createDirectory_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      if (result.__isset.ioe) {
        throw result.Ioe;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_createFile(AsyncCallback callback, object state, string path, CreateFileTOptions options)
    {
      return send_createFile(callback, state, path, options);
    }

    public void End_createFile(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_createFile();
    }

    #endif

    /// <summary>
    /// Creates a file.
    /// </summary>
    /// <param name="path">the path of the file</param>
    /// <param name="options">the options for creating the file</param>
    public void createFile(string path, CreateFileTOptions options)
    {
      #if !SILVERLIGHT
      send_createFile(path, options);
      recv_createFile();

      #else
      var asyncResult = Begin_createFile(null, null, path, options);
      End_createFile(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_createFile(AsyncCallback callback, object state, string path, CreateFileTOptions options)
    #else
    public void send_createFile(string path, CreateFileTOptions options)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("createFile", TMessageType.Call, seqid_));
      createFile_args args = new createFile_args();
      args.Path = path;
      args.Options = options;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_createFile()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      createFile_result result = new createFile_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      if (result.__isset.ioe) {
        throw result.Ioe;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_free(AsyncCallback callback, object state, string path, bool recursive)
    {
      return send_free(callback, state, path, recursive);
    }

    public void End_free(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_free();
    }

    #endif

    /// <summary>
    /// Frees the given file or directory from Alluxio.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    /// <param name="recursive">whether to free recursively</param>
    public void free(string path, bool recursive)
    {
      #if !SILVERLIGHT
      send_free(path, recursive);
      recv_free();

      #else
      var asyncResult = Begin_free(null, null, path, recursive);
      End_free(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_free(AsyncCallback callback, object state, string path, bool recursive)
    #else
    public void send_free(string path, bool recursive)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("free", TMessageType.Call, seqid_));
      free_args args = new free_args();
      args.Path = path;
      args.Recursive = recursive;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_free()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      free_result result = new free_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_getFileBlockInfoList(AsyncCallback callback, object state, string path)
    {
      return send_getFileBlockInfoList(callback, state, path);
    }

    public List<FileBlockInfo> End_getFileBlockInfoList(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_getFileBlockInfoList();
    }

    #endif

    /// <summary>
    /// Returns the list of file blocks information for the given file.
    /// 
    /// THIS METHOD IS DEPRECATED SINCE VERSION 1.1 AND WILL BE REMOVED IN VERSION 2.0.
    /// </summary>
    /// <param name="path">the path of the file</param>
    public List<FileBlockInfo> getFileBlockInfoList(string path)
    {
      #if !SILVERLIGHT
      send_getFileBlockInfoList(path);
      return recv_getFileBlockInfoList();

      #else
      var asyncResult = Begin_getFileBlockInfoList(null, null, path);
      return End_getFileBlockInfoList(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_getFileBlockInfoList(AsyncCallback callback, object state, string path)
    #else
    public void send_getFileBlockInfoList(string path)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("getFileBlockInfoList", TMessageType.Call, seqid_));
      getFileBlockInfoList_args args = new getFileBlockInfoList_args();
      args.Path = path;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public List<FileBlockInfo> recv_getFileBlockInfoList()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      getFileBlockInfoList_result result = new getFileBlockInfoList_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getFileBlockInfoList failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_getStatus(AsyncCallback callback, object state, string path)
    {
      return send_getStatus(callback, state, path);
    }

    public FileInfo End_getStatus(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_getStatus();
    }

    #endif

    /// <summary>
    /// Returns the status of the file or directory.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    public FileInfo getStatus(string path)
    {
      #if !SILVERLIGHT
      send_getStatus(path);
      return recv_getStatus();

      #else
      var asyncResult = Begin_getStatus(null, null, path);
      return End_getStatus(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_getStatus(AsyncCallback callback, object state, string path)
    #else
    public void send_getStatus(string path)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("getStatus", TMessageType.Call, seqid_));
      getStatus_args args = new getStatus_args();
      args.Path = path;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public FileInfo recv_getStatus()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      getStatus_result result = new getStatus_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getStatus failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_getStatusInternal(AsyncCallback callback, object state, long fileId)
    {
      return send_getStatusInternal(callback, state, fileId);
    }

    public FileInfo End_getStatusInternal(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_getStatusInternal();
    }

    #endif

    /// <summary>
    /// Returns the status of the file or directory, only used internally by servers.
    /// 
    /// THIS METHOD IS DEPRECATED SINCE VERSION 1.1 AND WILL BE REMOVED IN VERSION 2.0.
    /// </summary>
    /// <param name="fileId">the id of the file or directory</param>
    public FileInfo getStatusInternal(long fileId)
    {
      #if !SILVERLIGHT
      send_getStatusInternal(fileId);
      return recv_getStatusInternal();

      #else
      var asyncResult = Begin_getStatusInternal(null, null, fileId);
      return End_getStatusInternal(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_getStatusInternal(AsyncCallback callback, object state, long fileId)
    #else
    public void send_getStatusInternal(long fileId)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("getStatusInternal", TMessageType.Call, seqid_));
      getStatusInternal_args args = new getStatusInternal_args();
      args.FileId = fileId;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public FileInfo recv_getStatusInternal()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      getStatusInternal_result result = new getStatusInternal_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getStatusInternal failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_getNewBlockIdForFile(AsyncCallback callback, object state, string path)
    {
      return send_getNewBlockIdForFile(callback, state, path);
    }

    public long End_getNewBlockIdForFile(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_getNewBlockIdForFile();
    }

    #endif

    /// <summary>
    /// Generates a new block id for the given file.
    /// </summary>
    /// <param name="path">the path of the file</param>
    public long getNewBlockIdForFile(string path)
    {
      #if !SILVERLIGHT
      send_getNewBlockIdForFile(path);
      return recv_getNewBlockIdForFile();

      #else
      var asyncResult = Begin_getNewBlockIdForFile(null, null, path);
      return End_getNewBlockIdForFile(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_getNewBlockIdForFile(AsyncCallback callback, object state, string path)
    #else
    public void send_getNewBlockIdForFile(string path)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("getNewBlockIdForFile", TMessageType.Call, seqid_));
      getNewBlockIdForFile_args args = new getNewBlockIdForFile_args();
      args.Path = path;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public long recv_getNewBlockIdForFile()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      getNewBlockIdForFile_result result = new getNewBlockIdForFile_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNewBlockIdForFile failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_getUfsAddress(AsyncCallback callback, object state)
    {
      return send_getUfsAddress(callback, state);
    }

    public string End_getUfsAddress(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_getUfsAddress();
    }

    #endif

    /// <summary>
    /// Returns the UFS address of the root mount point.
    /// 
    /// THIS METHOD IS DEPRECATED SINCE VERSION 1.1 AND WILL BE REMOVED IN VERSION 2.0.
    /// </summary>
    public string getUfsAddress()
    {
      #if !SILVERLIGHT
      send_getUfsAddress();
      return recv_getUfsAddress();

      #else
      var asyncResult = Begin_getUfsAddress(null, null);
      return End_getUfsAddress(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_getUfsAddress(AsyncCallback callback, object state)
    #else
    public void send_getUfsAddress()
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("getUfsAddress", TMessageType.Call, seqid_));
      getUfsAddress_args args = new getUfsAddress_args();
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public string recv_getUfsAddress()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      getUfsAddress_result result = new getUfsAddress_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getUfsAddress failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_listStatus(AsyncCallback callback, object state, string path, ListStatusTOptions options)
    {
      return send_listStatus(callback, state, path, options);
    }

    public List<FileInfo> End_listStatus(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_listStatus();
    }

    #endif

    /// <summary>
    /// If the path points to a file, the method returns a singleton with its file information.
    /// If the path points to a directory, the method returns a list with file information for the
    /// directory contents.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    /// <param name="options">listStatus options</param>
    public List<FileInfo> listStatus(string path, ListStatusTOptions options)
    {
      #if !SILVERLIGHT
      send_listStatus(path, options);
      return recv_listStatus();

      #else
      var asyncResult = Begin_listStatus(null, null, path, options);
      return End_listStatus(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_listStatus(AsyncCallback callback, object state, string path, ListStatusTOptions options)
    #else
    public void send_listStatus(string path, ListStatusTOptions options)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("listStatus", TMessageType.Call, seqid_));
      listStatus_args args = new listStatus_args();
      args.Path = path;
      args.Options = options;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public List<FileInfo> recv_listStatus()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      listStatus_result result = new listStatus_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listStatus failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_loadMetadata(AsyncCallback callback, object state, string ufsPath, bool recursive)
    {
      return send_loadMetadata(callback, state, ufsPath, recursive);
    }

    public long End_loadMetadata(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      return recv_loadMetadata();
    }

    #endif

    /// <summary>
    /// Loads metadata for the object identified by the given Alluxio path from UFS into Alluxio.
    /// 
    /// THIS METHOD IS DEPRECATED SINCE VERSION 1.1 AND WILL BE REMOVED IN VERSION 2.0.
    /// </summary>
    /// <param name="ufsPath">the path of the under file system</param>
    /// <param name="recursive">whether to load meta data recursively</param>
    public long loadMetadata(string ufsPath, bool recursive)
    {
      #if !SILVERLIGHT
      send_loadMetadata(ufsPath, recursive);
      return recv_loadMetadata();

      #else
      var asyncResult = Begin_loadMetadata(null, null, ufsPath, recursive);
      return End_loadMetadata(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_loadMetadata(AsyncCallback callback, object state, string ufsPath, bool recursive)
    #else
    public void send_loadMetadata(string ufsPath, bool recursive)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("loadMetadata", TMessageType.Call, seqid_));
      loadMetadata_args args = new loadMetadata_args();
      args.UfsPath = ufsPath;
      args.Recursive = recursive;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public long recv_loadMetadata()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      loadMetadata_result result = new loadMetadata_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.success) {
        return result.Success;
      }
      if (result.__isset.e) {
        throw result.E;
      }
      if (result.__isset.ioe) {
        throw result.Ioe;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "loadMetadata failed: unknown result");
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_mount(AsyncCallback callback, object state, string alluxioPath, string ufsPath, MountTOptions options)
    {
      return send_mount(callback, state, alluxioPath, ufsPath, options);
    }

    public void End_mount(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_mount();
    }

    #endif

    /// <summary>
    /// Creates a new "mount point", mounts the given UFS path in the Alluxio namespace at the given
    /// path. The path should not exist and should not be nested under any existing mount point.
    /// </summary>
    /// <param name="alluxioPath">the path of alluxio mount point</param>
    /// <param name="ufsPath">the path of the under file system</param>
    /// <param name="options">the options for creating the mount point</param>
    public void mount(string alluxioPath, string ufsPath, MountTOptions options)
    {
      #if !SILVERLIGHT
      send_mount(alluxioPath, ufsPath, options);
      recv_mount();

      #else
      var asyncResult = Begin_mount(null, null, alluxioPath, ufsPath, options);
      End_mount(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_mount(AsyncCallback callback, object state, string alluxioPath, string ufsPath, MountTOptions options)
    #else
    public void send_mount(string alluxioPath, string ufsPath, MountTOptions options)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("mount", TMessageType.Call, seqid_));
      mount_args args = new mount_args();
      args.AlluxioPath = alluxioPath;
      args.UfsPath = ufsPath;
      args.Options = options;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_mount()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      mount_result result = new mount_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      if (result.__isset.ioe) {
        throw result.Ioe;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_remove(AsyncCallback callback, object state, string path, bool recursive)
    {
      return send_remove(callback, state, path, recursive);
    }

    public void End_remove(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_remove();
    }

    #endif

    /// <summary>
    /// Deletes a file or a directory and returns whether the remove operation succeeded.
    /// NOTE: Unfortunately, the method cannot be called "delete" as that is a reserved Thrift keyword.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    /// <param name="recursive">whether to remove recursively</param>
    public void @remove(string path, bool recursive)
    {
      #if !SILVERLIGHT
      send_remove(path, recursive);
      recv_remove();

      #else
      var asyncResult = Begin_remove(null, null, path, recursive);
      End_remove(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_remove(AsyncCallback callback, object state, string path, bool recursive)
    #else
    public void send_remove(string path, bool recursive)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("remove", TMessageType.Call, seqid_));
      remove_args args = new remove_args();
      args.Path = path;
      args.Recursive = recursive;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_remove()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      remove_result result = new remove_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_rename(AsyncCallback callback, object state, string path, string dstPath)
    {
      return send_rename(callback, state, path, dstPath);
    }

    public void End_rename(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_rename();
    }

    #endif

    /// <summary>
    /// Renames a file or a directory.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    /// <param name="dstPath">the desinationpath of the file</param>
    public void rename(string path, string dstPath)
    {
      #if !SILVERLIGHT
      send_rename(path, dstPath);
      recv_rename();

      #else
      var asyncResult = Begin_rename(null, null, path, dstPath);
      End_rename(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_rename(AsyncCallback callback, object state, string path, string dstPath)
    #else
    public void send_rename(string path, string dstPath)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("rename", TMessageType.Call, seqid_));
      rename_args args = new rename_args();
      args.Path = path;
      args.DstPath = dstPath;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_rename()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      rename_result result = new rename_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      if (result.__isset.ioe) {
        throw result.Ioe;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_setAttribute(AsyncCallback callback, object state, string path, SetAttributeTOptions options)
    {
      return send_setAttribute(callback, state, path, options);
    }

    public void End_setAttribute(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_setAttribute();
    }

    #endif

    /// <summary>
    /// Sets file or directory attributes.
    /// </summary>
    /// <param name="path">the path of the file or directory</param>
    /// <param name="options">the method options</param>
    public void setAttribute(string path, SetAttributeTOptions options)
    {
      #if !SILVERLIGHT
      send_setAttribute(path, options);
      recv_setAttribute();

      #else
      var asyncResult = Begin_setAttribute(null, null, path, options);
      End_setAttribute(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_setAttribute(AsyncCallback callback, object state, string path, SetAttributeTOptions options)
    #else
    public void send_setAttribute(string path, SetAttributeTOptions options)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("setAttribute", TMessageType.Call, seqid_));
      setAttribute_args args = new setAttribute_args();
      args.Path = path;
      args.Options = options;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_setAttribute()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      setAttribute_result result = new setAttribute_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_scheduleAsyncPersist(AsyncCallback callback, object state, string path)
    {
      return send_scheduleAsyncPersist(callback, state, path);
    }

    public void End_scheduleAsyncPersist(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_scheduleAsyncPersist();
    }

    #endif

    /// <summary>
    /// Schedules async persistence.
    /// </summary>
    /// <param name="path">the path of the file</param>
    public void scheduleAsyncPersist(string path)
    {
      #if !SILVERLIGHT
      send_scheduleAsyncPersist(path);
      recv_scheduleAsyncPersist();

      #else
      var asyncResult = Begin_scheduleAsyncPersist(null, null, path);
      End_scheduleAsyncPersist(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_scheduleAsyncPersist(AsyncCallback callback, object state, string path)
    #else
    public void send_scheduleAsyncPersist(string path)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("scheduleAsyncPersist", TMessageType.Call, seqid_));
      scheduleAsyncPersist_args args = new scheduleAsyncPersist_args();
      args.Path = path;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_scheduleAsyncPersist()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      scheduleAsyncPersist_result result = new scheduleAsyncPersist_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      return;
    }

    
    #if SILVERLIGHT
    public IAsyncResult Begin_unmount(AsyncCallback callback, object state, string alluxioPath)
    {
      return send_unmount(callback, state, alluxioPath);
    }

    public void End_unmount(IAsyncResult asyncResult)
    {
      oprot_.Transport.EndFlush(asyncResult);
      recv_unmount();
    }

    #endif

    /// <summary>
    /// Deletes an existing "mount point", voiding the Alluxio namespace at the given path. The path
    /// should correspond to an existing mount point. Any files in its subtree that are backed by UFS
    /// will be persisted before they are removed from the Alluxio namespace.
    /// </summary>
    /// <param name="alluxioPath">the path of the alluxio mount point</param>
    public void unmount(string alluxioPath)
    {
      #if !SILVERLIGHT
      send_unmount(alluxioPath);
      recv_unmount();

      #else
      var asyncResult = Begin_unmount(null, null, alluxioPath);
      End_unmount(asyncResult);

      #endif
    }
    #if SILVERLIGHT
    public IAsyncResult send_unmount(AsyncCallback callback, object state, string alluxioPath)
    #else
    public void send_unmount(string alluxioPath)
    #endif
    {
      oprot_.WriteMessageBegin(new TMessage("unmount", TMessageType.Call, seqid_));
      unmount_args args = new unmount_args();
      args.AlluxioPath = alluxioPath;
      args.Write(oprot_);
      oprot_.WriteMessageEnd();
      #if SILVERLIGHT
      return oprot_.Transport.BeginFlush(callback, state);
      #else
      oprot_.Transport.Flush();
      #endif
    }

    public void recv_unmount()
    {
      TMessage msg = iprot_.ReadMessageBegin();
      if (msg.Type == TMessageType.Exception) {
        TApplicationException x = TApplicationException.Read(iprot_);
        iprot_.ReadMessageEnd();
        throw x;
      }
      unmount_result result = new unmount_result();
      result.Read(iprot_);
      iprot_.ReadMessageEnd();
      if (result.__isset.e) {
        throw result.E;
      }
      if (result.__isset.ioe) {
        throw result.Ioe;
      }
      return;
    }

  }
  public class Processor : AlluxioService.Processor, TProcessor {
    public Processor(Iface iface) : base(iface)
    {
      iface_ = iface;
      processMap_["completeFile"] = completeFile_Process;
      processMap_["createDirectory"] = createDirectory_Process;
      processMap_["createFile"] = createFile_Process;
      processMap_["free"] = free_Process;
      processMap_["getFileBlockInfoList"] = getFileBlockInfoList_Process;
      processMap_["getStatus"] = getStatus_Process;
      processMap_["getStatusInternal"] = getStatusInternal_Process;
      processMap_["getNewBlockIdForFile"] = getNewBlockIdForFile_Process;
      processMap_["getUfsAddress"] = getUfsAddress_Process;
      processMap_["listStatus"] = listStatus_Process;
      processMap_["loadMetadata"] = loadMetadata_Process;
      processMap_["mount"] = mount_Process;
      processMap_["remove"] = remove_Process;
      processMap_["rename"] = rename_Process;
      processMap_["setAttribute"] = setAttribute_Process;
      processMap_["scheduleAsyncPersist"] = scheduleAsyncPersist_Process;
      processMap_["unmount"] = unmount_Process;
    }

    private Iface iface_;

    public new bool Process(TProtocol iprot, TProtocol oprot)
    {
      try
      {
        TMessage msg = iprot.ReadMessageBegin();
        ProcessFunction fn;
        processMap_.TryGetValue(msg.Name, out fn);
        if (fn == null) {
          TProtocolUtil.Skip(iprot, TType.Struct);
          iprot.ReadMessageEnd();
          TApplicationException x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
          oprot.WriteMessageBegin(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID));
          x.Write(oprot);
          oprot.WriteMessageEnd();
          oprot.Transport.Flush();
          return true;
        }
        fn(msg.SeqID, iprot, oprot);
      }
      catch (IOException)
      {
        return false;
      }
      return true;
    }

    public void completeFile_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      completeFile_args args = new completeFile_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      completeFile_result result = new completeFile_result();
      try {
        iface_.completeFile(args.Path, args.Options);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("completeFile", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void createDirectory_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      createDirectory_args args = new createDirectory_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      createDirectory_result result = new createDirectory_result();
      try {
        iface_.createDirectory(args.Path, args.Options);
      } catch (AlluxioTException e) {
        result.E = e;
      } catch (ThriftIOException ioe) {
        result.Ioe = ioe;
      }
      oprot.WriteMessageBegin(new TMessage("createDirectory", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void createFile_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      createFile_args args = new createFile_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      createFile_result result = new createFile_result();
      try {
        iface_.createFile(args.Path, args.Options);
      } catch (AlluxioTException e) {
        result.E = e;
      } catch (ThriftIOException ioe) {
        result.Ioe = ioe;
      }
      oprot.WriteMessageBegin(new TMessage("createFile", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void free_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      free_args args = new free_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      free_result result = new free_result();
      try {
        iface_.free(args.Path, args.Recursive);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("free", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void getFileBlockInfoList_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      getFileBlockInfoList_args args = new getFileBlockInfoList_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      getFileBlockInfoList_result result = new getFileBlockInfoList_result();
      try {
        result.Success = iface_.getFileBlockInfoList(args.Path);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("getFileBlockInfoList", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void getStatus_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      getStatus_args args = new getStatus_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      getStatus_result result = new getStatus_result();
      try {
        result.Success = iface_.getStatus(args.Path);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("getStatus", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void getStatusInternal_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      getStatusInternal_args args = new getStatusInternal_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      getStatusInternal_result result = new getStatusInternal_result();
      try {
        result.Success = iface_.getStatusInternal(args.FileId);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("getStatusInternal", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void getNewBlockIdForFile_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      getNewBlockIdForFile_args args = new getNewBlockIdForFile_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      getNewBlockIdForFile_result result = new getNewBlockIdForFile_result();
      try {
        result.Success = iface_.getNewBlockIdForFile(args.Path);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("getNewBlockIdForFile", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void getUfsAddress_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      getUfsAddress_args args = new getUfsAddress_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      getUfsAddress_result result = new getUfsAddress_result();
      result.Success = iface_.getUfsAddress();
      oprot.WriteMessageBegin(new TMessage("getUfsAddress", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void listStatus_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      listStatus_args args = new listStatus_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      listStatus_result result = new listStatus_result();
      try {
        result.Success = iface_.listStatus(args.Path, args.Options);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("listStatus", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void loadMetadata_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      loadMetadata_args args = new loadMetadata_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      loadMetadata_result result = new loadMetadata_result();
      try {
        result.Success = iface_.loadMetadata(args.UfsPath, args.Recursive);
      } catch (AlluxioTException e) {
        result.E = e;
      } catch (ThriftIOException ioe) {
        result.Ioe = ioe;
      }
      oprot.WriteMessageBegin(new TMessage("loadMetadata", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void mount_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      mount_args args = new mount_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      mount_result result = new mount_result();
      try {
        iface_.mount(args.AlluxioPath, args.UfsPath, args.Options);
      } catch (AlluxioTException e) {
        result.E = e;
      } catch (ThriftIOException ioe) {
        result.Ioe = ioe;
      }
      oprot.WriteMessageBegin(new TMessage("mount", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void remove_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      remove_args args = new remove_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      remove_result result = new remove_result();
      try {
        iface_.@remove(args.Path, args.Recursive);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("remove", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void rename_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      rename_args args = new rename_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      rename_result result = new rename_result();
      try {
        iface_.rename(args.Path, args.DstPath);
      } catch (AlluxioTException e) {
        result.E = e;
      } catch (ThriftIOException ioe) {
        result.Ioe = ioe;
      }
      oprot.WriteMessageBegin(new TMessage("rename", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void setAttribute_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      setAttribute_args args = new setAttribute_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      setAttribute_result result = new setAttribute_result();
      try {
        iface_.setAttribute(args.Path, args.Options);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("setAttribute", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void scheduleAsyncPersist_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      scheduleAsyncPersist_args args = new scheduleAsyncPersist_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      scheduleAsyncPersist_result result = new scheduleAsyncPersist_result();
      try {
        iface_.scheduleAsyncPersist(args.Path);
      } catch (AlluxioTException e) {
        result.E = e;
      }
      oprot.WriteMessageBegin(new TMessage("scheduleAsyncPersist", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

    public void unmount_Process(int seqid, TProtocol iprot, TProtocol oprot)
    {
      unmount_args args = new unmount_args();
      args.Read(iprot);
      iprot.ReadMessageEnd();
      unmount_result result = new unmount_result();
      try {
        iface_.unmount(args.AlluxioPath);
      } catch (AlluxioTException e) {
        result.E = e;
      } catch (ThriftIOException ioe) {
        result.Ioe = ioe;
      }
      oprot.WriteMessageBegin(new TMessage("unmount", TMessageType.Reply, seqid)); 
      result.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class completeFile_args : TBase
  {
    private string _path;
    private CompleteFileTOptions _options;

    /// <summary>
    /// the path of the file
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }

    /// <summary>
    /// the method options
    /// </summary>
    public CompleteFileTOptions Options
    {
      get
      {
        return _options;
      }
      set
      {
        __isset.options = true;
        this._options = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
      public bool options;
    }

    public completeFile_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Options = new CompleteFileTOptions();
                Options.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("completeFile_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        if (Options != null && __isset.options) {
          field.Name = "options";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Options.Write(oprot);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("completeFile_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      if (Options != null && __isset.options) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Options: ");
        __sb.Append(Options== null ? "<null>" : Options.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class completeFile_result : TBase
  {
    private AlluxioTException _e;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
    }

    public completeFile_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("completeFile_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("completeFile_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class createDirectory_args : TBase
  {
    private string _path;
    private CreateDirectoryTOptions _options;

    /// <summary>
    /// the path of the directory
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }

    /// <summary>
    /// the method options
    /// </summary>
    public CreateDirectoryTOptions Options
    {
      get
      {
        return _options;
      }
      set
      {
        __isset.options = true;
        this._options = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
      public bool options;
    }

    public createDirectory_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Options = new CreateDirectoryTOptions();
                Options.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("createDirectory_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        if (Options != null && __isset.options) {
          field.Name = "options";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Options.Write(oprot);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("createDirectory_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      if (Options != null && __isset.options) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Options: ");
        __sb.Append(Options== null ? "<null>" : Options.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class createDirectory_result : TBase
  {
    private AlluxioTException _e;
    private ThriftIOException _ioe;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }

    public ThriftIOException Ioe
    {
      get
      {
        return _ioe;
      }
      set
      {
        __isset.ioe = true;
        this._ioe = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
      public bool ioe;
    }

    public createDirectory_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Ioe = new ThriftIOException();
                Ioe.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("createDirectory_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.ioe) {
          if (Ioe != null) {
            field.Name = "Ioe";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Ioe.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("createDirectory_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      if (Ioe != null && __isset.ioe) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ioe: ");
        __sb.Append(Ioe== null ? "<null>" : Ioe.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class createFile_args : TBase
  {
    private string _path;
    private CreateFileTOptions _options;

    /// <summary>
    /// the path of the file
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }

    /// <summary>
    /// the options for creating the file
    /// </summary>
    public CreateFileTOptions Options
    {
      get
      {
        return _options;
      }
      set
      {
        __isset.options = true;
        this._options = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
      public bool options;
    }

    public createFile_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Options = new CreateFileTOptions();
                Options.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("createFile_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        if (Options != null && __isset.options) {
          field.Name = "options";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Options.Write(oprot);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("createFile_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      if (Options != null && __isset.options) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Options: ");
        __sb.Append(Options== null ? "<null>" : Options.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class createFile_result : TBase
  {
    private AlluxioTException _e;
    private ThriftIOException _ioe;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }

    public ThriftIOException Ioe
    {
      get
      {
        return _ioe;
      }
      set
      {
        __isset.ioe = true;
        this._ioe = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
      public bool ioe;
    }

    public createFile_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Ioe = new ThriftIOException();
                Ioe.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("createFile_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.ioe) {
          if (Ioe != null) {
            field.Name = "Ioe";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Ioe.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("createFile_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      if (Ioe != null && __isset.ioe) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ioe: ");
        __sb.Append(Ioe== null ? "<null>" : Ioe.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class free_args : TBase
  {
    private string _path;
    private bool _recursive;

    /// <summary>
    /// the path of the file or directory
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }

    /// <summary>
    /// whether to free recursively
    /// </summary>
    public bool Recursive
    {
      get
      {
        return _recursive;
      }
      set
      {
        __isset.recursive = true;
        this._recursive = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
      public bool recursive;
    }

    public free_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Bool) {
                Recursive = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("free_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        if (__isset.recursive) {
          field.Name = "recursive";
          field.Type = TType.Bool;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(Recursive);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("free_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      if (__isset.recursive) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Recursive: ");
        __sb.Append(Recursive);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class free_result : TBase
  {
    private AlluxioTException _e;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
    }

    public free_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("free_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("free_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class getFileBlockInfoList_args : TBase
  {
    private string _path;

    /// <summary>
    /// the path of the file
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
    }

    public getFileBlockInfoList_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("getFileBlockInfoList_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("getFileBlockInfoList_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class getFileBlockInfoList_result : TBase
  {
    private List<FileBlockInfo> _success;
    private AlluxioTException _e;

    public List<FileBlockInfo> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
    }

    public getFileBlockInfoList_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List) {
                {
                  Success = new List<FileBlockInfo>();
                  TList _list29 = iprot.ReadListBegin();
                  for( int _i30 = 0; _i30 < _list29.Count; ++_i30)
                  {
                    FileBlockInfo _elem31;
                    _elem31 = new FileBlockInfo();
                    _elem31.Read(iprot);
                    Success.Add(_elem31);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("getFileBlockInfoList_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          if (Success != null) {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
              foreach (FileBlockInfo _iter32 in Success)
              {
                _iter32.Write(oprot);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("getFileBlockInfoList_result(");
      bool __first = true;
      if (Success != null && __isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success);
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class getStatus_args : TBase
  {
    private string _path;

    /// <summary>
    /// the path of the file or directory
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
    }

    public getStatus_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("getStatus_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("getStatus_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class getStatus_result : TBase
  {
    private FileInfo _success;
    private AlluxioTException _e;

    public FileInfo Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
    }

    public getStatus_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Struct) {
                Success = new FileInfo();
                Success.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("getStatus_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          if (Success != null) {
            field.Name = "Success";
            field.Type = TType.Struct;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            Success.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("getStatus_result(");
      bool __first = true;
      if (Success != null && __isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success== null ? "<null>" : Success.ToString());
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class getStatusInternal_args : TBase
  {
    private long _fileId;

    /// <summary>
    /// the id of the file or directory
    /// </summary>
    public long FileId
    {
      get
      {
        return _fileId;
      }
      set
      {
        __isset.fileId = true;
        this._fileId = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool fileId;
    }

    public getStatusInternal_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                FileId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("getStatusInternal_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.fileId) {
          field.Name = "fileId";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(FileId);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("getStatusInternal_args(");
      bool __first = true;
      if (__isset.fileId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("FileId: ");
        __sb.Append(FileId);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class getStatusInternal_result : TBase
  {
    private FileInfo _success;
    private AlluxioTException _e;

    public FileInfo Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
    }

    public getStatusInternal_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Struct) {
                Success = new FileInfo();
                Success.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("getStatusInternal_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          if (Success != null) {
            field.Name = "Success";
            field.Type = TType.Struct;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            Success.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("getStatusInternal_result(");
      bool __first = true;
      if (Success != null && __isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success== null ? "<null>" : Success.ToString());
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class getNewBlockIdForFile_args : TBase
  {
    private string _path;

    /// <summary>
    /// the path of the file
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
    }

    public getNewBlockIdForFile_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("getNewBlockIdForFile_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("getNewBlockIdForFile_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class getNewBlockIdForFile_result : TBase
  {
    private long _success;
    private AlluxioTException _e;

    public long Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
    }

    public getNewBlockIdForFile_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.I64) {
                Success = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("getNewBlockIdForFile_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          field.Name = "Success";
          field.Type = TType.I64;
          field.ID = 0;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(Success);
          oprot.WriteFieldEnd();
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("getNewBlockIdForFile_result(");
      bool __first = true;
      if (__isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success);
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class getUfsAddress_args : TBase
  {

    public getUfsAddress_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("getUfsAddress_args");
        oprot.WriteStructBegin(struc);
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("getUfsAddress_args(");
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class getUfsAddress_result : TBase
  {
    private string _success;

    public string Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
    }

    public getUfsAddress_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.String) {
                Success = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("getUfsAddress_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          if (Success != null) {
            field.Name = "Success";
            field.Type = TType.String;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Success);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("getUfsAddress_result(");
      bool __first = true;
      if (Success != null && __isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class listStatus_args : TBase
  {
    private string _path;
    private ListStatusTOptions _options;

    /// <summary>
    /// the path of the file or directory
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }

    /// <summary>
    /// listStatus options
    /// </summary>
    public ListStatusTOptions Options
    {
      get
      {
        return _options;
      }
      set
      {
        __isset.options = true;
        this._options = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
      public bool options;
    }

    public listStatus_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Options = new ListStatusTOptions();
                Options.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("listStatus_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        if (Options != null && __isset.options) {
          field.Name = "options";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Options.Write(oprot);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("listStatus_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      if (Options != null && __isset.options) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Options: ");
        __sb.Append(Options== null ? "<null>" : Options.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class listStatus_result : TBase
  {
    private List<FileInfo> _success;
    private AlluxioTException _e;

    public List<FileInfo> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
    }

    public listStatus_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List) {
                {
                  Success = new List<FileInfo>();
                  TList _list33 = iprot.ReadListBegin();
                  for( int _i34 = 0; _i34 < _list33.Count; ++_i34)
                  {
                    FileInfo _elem35;
                    _elem35 = new FileInfo();
                    _elem35.Read(iprot);
                    Success.Add(_elem35);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("listStatus_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          if (Success != null) {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
              foreach (FileInfo _iter36 in Success)
              {
                _iter36.Write(oprot);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("listStatus_result(");
      bool __first = true;
      if (Success != null && __isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success);
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class loadMetadata_args : TBase
  {
    private string _ufsPath;
    private bool _recursive;

    /// <summary>
    /// the path of the under file system
    /// </summary>
    public string UfsPath
    {
      get
      {
        return _ufsPath;
      }
      set
      {
        __isset.ufsPath = true;
        this._ufsPath = value;
      }
    }

    /// <summary>
    /// whether to load meta data recursively
    /// </summary>
    public bool Recursive
    {
      get
      {
        return _recursive;
      }
      set
      {
        __isset.recursive = true;
        this._recursive = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool ufsPath;
      public bool recursive;
    }

    public loadMetadata_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                UfsPath = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Bool) {
                Recursive = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("loadMetadata_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (UfsPath != null && __isset.ufsPath) {
          field.Name = "ufsPath";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(UfsPath);
          oprot.WriteFieldEnd();
        }
        if (__isset.recursive) {
          field.Name = "recursive";
          field.Type = TType.Bool;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(Recursive);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("loadMetadata_args(");
      bool __first = true;
      if (UfsPath != null && __isset.ufsPath) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("UfsPath: ");
        __sb.Append(UfsPath);
      }
      if (__isset.recursive) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Recursive: ");
        __sb.Append(Recursive);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class loadMetadata_result : TBase
  {
    private long _success;
    private AlluxioTException _e;
    private ThriftIOException _ioe;

    public long Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }

    public ThriftIOException Ioe
    {
      get
      {
        return _ioe;
      }
      set
      {
        __isset.ioe = true;
        this._ioe = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool success;
      public bool e;
      public bool ioe;
    }

    public loadMetadata_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.I64) {
                Success = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Ioe = new ThriftIOException();
                Ioe.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("loadMetadata_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.success) {
          field.Name = "Success";
          field.Type = TType.I64;
          field.ID = 0;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(Success);
          oprot.WriteFieldEnd();
        } else if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.ioe) {
          if (Ioe != null) {
            field.Name = "Ioe";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Ioe.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("loadMetadata_result(");
      bool __first = true;
      if (__isset.success) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Success: ");
        __sb.Append(Success);
      }
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      if (Ioe != null && __isset.ioe) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ioe: ");
        __sb.Append(Ioe== null ? "<null>" : Ioe.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class mount_args : TBase
  {
    private string _alluxioPath;
    private string _ufsPath;
    private MountTOptions _options;

    /// <summary>
    /// the path of alluxio mount point
    /// </summary>
    public string AlluxioPath
    {
      get
      {
        return _alluxioPath;
      }
      set
      {
        __isset.alluxioPath = true;
        this._alluxioPath = value;
      }
    }

    /// <summary>
    /// the path of the under file system
    /// </summary>
    public string UfsPath
    {
      get
      {
        return _ufsPath;
      }
      set
      {
        __isset.ufsPath = true;
        this._ufsPath = value;
      }
    }

    /// <summary>
    /// the options for creating the mount point
    /// </summary>
    public MountTOptions Options
    {
      get
      {
        return _options;
      }
      set
      {
        __isset.options = true;
        this._options = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool alluxioPath;
      public bool ufsPath;
      public bool options;
    }

    public mount_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                AlluxioPath = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.String) {
                UfsPath = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 3:
              if (field.Type == TType.Struct) {
                Options = new MountTOptions();
                Options.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("mount_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (AlluxioPath != null && __isset.alluxioPath) {
          field.Name = "alluxioPath";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(AlluxioPath);
          oprot.WriteFieldEnd();
        }
        if (UfsPath != null && __isset.ufsPath) {
          field.Name = "ufsPath";
          field.Type = TType.String;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(UfsPath);
          oprot.WriteFieldEnd();
        }
        if (Options != null && __isset.options) {
          field.Name = "options";
          field.Type = TType.Struct;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          Options.Write(oprot);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("mount_args(");
      bool __first = true;
      if (AlluxioPath != null && __isset.alluxioPath) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("AlluxioPath: ");
        __sb.Append(AlluxioPath);
      }
      if (UfsPath != null && __isset.ufsPath) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("UfsPath: ");
        __sb.Append(UfsPath);
      }
      if (Options != null && __isset.options) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Options: ");
        __sb.Append(Options== null ? "<null>" : Options.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class mount_result : TBase
  {
    private AlluxioTException _e;
    private ThriftIOException _ioe;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }

    public ThriftIOException Ioe
    {
      get
      {
        return _ioe;
      }
      set
      {
        __isset.ioe = true;
        this._ioe = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
      public bool ioe;
    }

    public mount_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Ioe = new ThriftIOException();
                Ioe.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("mount_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.ioe) {
          if (Ioe != null) {
            field.Name = "Ioe";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Ioe.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("mount_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      if (Ioe != null && __isset.ioe) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ioe: ");
        __sb.Append(Ioe== null ? "<null>" : Ioe.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class remove_args : TBase
  {
    private string _path;
    private bool _recursive;

    /// <summary>
    /// the path of the file or directory
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }

    /// <summary>
    /// whether to remove recursively
    /// </summary>
    public bool Recursive
    {
      get
      {
        return _recursive;
      }
      set
      {
        __isset.recursive = true;
        this._recursive = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
      public bool recursive;
    }

    public remove_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Bool) {
                Recursive = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("remove_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        if (__isset.recursive) {
          field.Name = "recursive";
          field.Type = TType.Bool;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(Recursive);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("remove_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      if (__isset.recursive) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Recursive: ");
        __sb.Append(Recursive);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class remove_result : TBase
  {
    private AlluxioTException _e;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
    }

    public remove_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("remove_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("remove_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class rename_args : TBase
  {
    private string _path;
    private string _dstPath;

    /// <summary>
    /// the path of the file or directory
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }

    /// <summary>
    /// the desinationpath of the file
    /// </summary>
    public string DstPath
    {
      get
      {
        return _dstPath;
      }
      set
      {
        __isset.dstPath = true;
        this._dstPath = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
      public bool dstPath;
    }

    public rename_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.String) {
                DstPath = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("rename_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        if (DstPath != null && __isset.dstPath) {
          field.Name = "dstPath";
          field.Type = TType.String;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(DstPath);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("rename_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      if (DstPath != null && __isset.dstPath) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("DstPath: ");
        __sb.Append(DstPath);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class rename_result : TBase
  {
    private AlluxioTException _e;
    private ThriftIOException _ioe;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }

    public ThriftIOException Ioe
    {
      get
      {
        return _ioe;
      }
      set
      {
        __isset.ioe = true;
        this._ioe = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
      public bool ioe;
    }

    public rename_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Ioe = new ThriftIOException();
                Ioe.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("rename_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.ioe) {
          if (Ioe != null) {
            field.Name = "Ioe";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Ioe.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("rename_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      if (Ioe != null && __isset.ioe) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ioe: ");
        __sb.Append(Ioe== null ? "<null>" : Ioe.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class setAttribute_args : TBase
  {
    private string _path;
    private SetAttributeTOptions _options;

    /// <summary>
    /// the path of the file or directory
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }

    /// <summary>
    /// the method options
    /// </summary>
    public SetAttributeTOptions Options
    {
      get
      {
        return _options;
      }
      set
      {
        __isset.options = true;
        this._options = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
      public bool options;
    }

    public setAttribute_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Options = new SetAttributeTOptions();
                Options.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("setAttribute_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        if (Options != null && __isset.options) {
          field.Name = "options";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Options.Write(oprot);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("setAttribute_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      if (Options != null && __isset.options) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Options: ");
        __sb.Append(Options== null ? "<null>" : Options.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class setAttribute_result : TBase
  {
    private AlluxioTException _e;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
    }

    public setAttribute_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("setAttribute_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("setAttribute_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class scheduleAsyncPersist_args : TBase
  {
    private string _path;

    /// <summary>
    /// the path of the file
    /// </summary>
    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool path;
    }

    public scheduleAsyncPersist_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                Path = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("scheduleAsyncPersist_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Path != null && __isset.path) {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Path);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("scheduleAsyncPersist_args(");
      bool __first = true;
      if (Path != null && __isset.path) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Path: ");
        __sb.Append(Path);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class scheduleAsyncPersist_result : TBase
  {
    private AlluxioTException _e;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
    }

    public scheduleAsyncPersist_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("scheduleAsyncPersist_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("scheduleAsyncPersist_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class unmount_args : TBase
  {
    private string _alluxioPath;

    /// <summary>
    /// the path of the alluxio mount point
    /// </summary>
    public string AlluxioPath
    {
      get
      {
        return _alluxioPath;
      }
      set
      {
        __isset.alluxioPath = true;
        this._alluxioPath = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool alluxioPath;
    }

    public unmount_args() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String) {
                AlluxioPath = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("unmount_args");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (AlluxioPath != null && __isset.alluxioPath) {
          field.Name = "alluxioPath";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(AlluxioPath);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("unmount_args(");
      bool __first = true;
      if (AlluxioPath != null && __isset.alluxioPath) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("AlluxioPath: ");
        __sb.Append(AlluxioPath);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }


  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class unmount_result : TBase
  {
    private AlluxioTException _e;
    private ThriftIOException _ioe;

    public AlluxioTException E
    {
      get
      {
        return _e;
      }
      set
      {
        __isset.e = true;
        this._e = value;
      }
    }

    public ThriftIOException Ioe
    {
      get
      {
        return _ioe;
      }
      set
      {
        __isset.ioe = true;
        this._ioe = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool e;
      public bool ioe;
    }

    public unmount_result() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct) {
                E = new AlluxioTException();
                E.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Struct) {
                Ioe = new ThriftIOException();
                Ioe.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("unmount_result");
        oprot.WriteStructBegin(struc);
        TField field = new TField();

        if (this.__isset.e) {
          if (E != null) {
            field.Name = "E";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            E.Write(oprot);
            oprot.WriteFieldEnd();
          }
        } else if (this.__isset.ioe) {
          if (Ioe != null) {
            field.Name = "Ioe";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Ioe.Write(oprot);
            oprot.WriteFieldEnd();
          }
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("unmount_result(");
      bool __first = true;
      if (E != null && __isset.e) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("E: ");
        __sb.Append(E== null ? "<null>" : E.ToString());
      }
      if (Ioe != null && __isset.ioe) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ioe: ");
        __sb.Append(Ioe== null ? "<null>" : Ioe.ToString());
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }

}
